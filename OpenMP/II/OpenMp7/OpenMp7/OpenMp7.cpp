//Oпределить две параллельные области, каждая из которых содержит итерационную конструкцию for 
//выполняющую инициализацию элементов одномерных массивов целых чисел a[12], b[12] и c[12]. 
//Число нитей перед первой областью задать равным 3, перед второй – равным 4. 
//Первая параллельная область выполняет инициализацию элементов массивов a и b с использованием статического распределения итераций, 
//размер порции итераций выбрать самостоятельно, 
//вторая параллельная область выполняет инициализацию элементов массива c по следующему правилу c[i] = a[i] + b[i],
//с использованием динамического распределения итераций, размер порции итераций выбрать самостоятельно. 
//В каждой области определить и выдать на экран количество нитей, номер нити и результат выполнения цикла. Убедиться в правильности работы программы.

// author : Kashapova Dilyara, 11-001

#include <omp.h>
#include <stdio.h>
#include <iostream>

//Директива OpenMP reduction позволяет собрать вместе в главном потоке результаты вычислений частичных сумм, разностей и т. п. 
//из параллельных потоков последующего параллельного структурного блока

int thread_cont_a = 3, thread_cont_b = 4;
int const AR_SIZE = 12;

int main() {
	int a[AR_SIZE], b[AR_SIZE], c[AR_SIZE];

	int it_a = 2, it_b = 4, it_c = 3;

	omp_set_dynamic(0);

	omp_set_num_threads(thread_cont_a);
#pragma omp parallel 
	{
#pragma omp for schedule(static)
		for (int i = 0; i < AR_SIZE; i++) {
			a[i] = i * it_a;
			b[i] = i * it_b;

			printf("Area 1: working thread number %d of %d threads, a[%d] = % d, b[%d] = % d\n", omp_get_thread_num(), omp_get_num_threads(), i, a[i], i, b[i]);
		}
	}

	std::cout << "\n";

	omp_set_num_threads(thread_cont_b);
#pragma omp parallel 
	{
#pragma omp for schedule(static)
		for (int i = 0; i < AR_SIZE; i++) {
			c[i] = (a[i] + b[i]) * it_c;

			printf("Area 2: working thread number %d of %d threads, c[%d] = % d\n", omp_get_thread_num(), omp_get_num_threads(), i, c[i]);
		}
	}
}


/*
static schedule означает, что блоки итераций статически сопоставляются с потоками выполнения в циклическом режиме. 
Преимущество статического планирования заключается в том, что среда выполнения OpenMP гарантирует, 
что если у вас есть два отдельных цикла с одинаковым количеством итераций и вы выполняете их с одинаковым количеством потоков 
с использованием статического планирования, то каждый поток получит точно такой же диапазон итераций ( с) в обеих параллельных областях

dynami cпланирование работ по принципу «первым пришел, первым обслужен». 
Два прогона с одинаковым количеством потоков могут (и, скорее всего, будут) создавать совершенно разные сопоставления «пространство итераций» -> «потоки»
*/